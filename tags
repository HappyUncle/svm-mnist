!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
C	svm/svm_struct_api_types.h	/^  double C;                    \/* trade-off between margin and loss *\/$/;"	m	struct:struct_learn_parm
CC	svm/Makefile	/^CC = gcc$/;"	m
CC	svm/svm_light/Makefile	/^CC = gcc$/;"	m
CC	svm/svm_struct/Makefile	/^CC = gcc$/;"	m
CCACHE	svm/svm_struct/svm_struct_learn.h	/^} CCACHE;$/;"	t	typeref:struct:ccache
CCACHEELEM	svm/svm_struct/svm_struct_learn.h	/^} CCACHEELEM;$/;"	t	typeref:struct:ccacheelem
CFLAGS	svm/Makefile	/^CFLAGS =   $(SFLAGS) -O3 -fomit-frame-pointer -ffast-math -Wall $/;"	m
CFLAGS	svm/svm_light/Makefile	/^CFLAGS=  $(SFLAGS) -O3                     # release C-Compiler flags$/;"	m
CFLAGS	svm/svm_struct/Makefile	/^CFLAGS =    $(SFLAGS) -O3 -fomit-frame-pointer -ffast-math -Wall $/;"	m
CFLOAT	svm/svm_light/svm_common.h	34;"	d
CLASSIFICATION	svm/svm_light/svm_common.h	50;"	d
COMPACT_CACHED_VECTORS	svm/svm_struct_api_types.h	46;"	d
COMPACT_ROUNDING_THRESH	svm/svm_struct_api_types.h	53;"	d
CONSTSET	svm/svm_struct/svm_struct_common.h	/^} CONSTSET;$/;"	t	typeref:struct:constset
CUSTOM	svm/svm_light/svm_common.h	47;"	d
DEFAULT_ALG_TYPE	svm/svm_struct_api_types.h	37;"	d
DEFAULT_EPS	svm/svm_struct_api_types.h	31;"	d
DEFAULT_LOSS_FCT	svm/svm_struct_api_types.h	35;"	d
DEFAULT_RESCALING	svm/svm_struct_api_types.h	33;"	d
DEF_LINDEP_SENSITIVITY	svm/svm_light/svm_hideo.c	49;"	d	file:
DEF_MAX_ITERATIONS	svm/svm_light/svm_hideo.c	48;"	d	file:
DEF_PRECISION	svm/svm_light/svm_hideo.c	47;"	d	file:
DEF_PRECISION_LINEAR	svm/svm_light/svm_loqo.c	29;"	d	file:
DEF_PRECISION_NONLINEAR	svm/svm_light/svm_loqo.c	30;"	d	file:
DOC	svm/svm_light/svm_common.h	/^} DOC;$/;"	t	typeref:struct:doc
DUAL_OPTIMAL	svm/svm_light/svm_hideo.c	37;"	d	file:
EPSILON_EQ	svm/svm_light/svm_hideo.c	51;"	d	file:
EPSILON_HIDEO	svm/svm_light/svm_hideo.c	50;"	d	file:
EXAMPLE	svm/svm_struct/svm_struct_common.h	/^} EXAMPLE;$/;"	t	typeref:struct:example
FNUM	svm/svm_light/svm_common.h	37;"	d
FNUM_MAX	svm/svm_light/svm_common.h	38;"	d
FVAL	svm/svm_light/svm_common.h	39;"	d
GRAM	svm/svm_light/svm_common.h	48;"	d
INST_NAME	svm/svm_struct_api_types.h	26;"	d
INST_VERSION	svm/svm_struct_api_types.h	27;"	d
INST_VERSION_DATE	svm/svm_struct_api_types.h	28;"	d
KERNEL_CACHE	svm/svm_light/svm_common.h	/^} KERNEL_CACHE;$/;"	t	typeref:struct:kernel_cache
KERNEL_PARM	svm/svm_light/svm_common.h	/^} KERNEL_PARM;$/;"	t	typeref:struct:kernel_parm
LABEL	svm/svm_struct_api_types.h	/^} LABEL;$/;"	t	typeref:struct:label
LARGEROUND	svm/svm_light/svm_hideo.c	42;"	d	file:
LD	svm/Makefile	/^LD = gcc$/;"	m
LD	svm/svm_light/Makefile	/^LD = gcc$/;"	m
LD	svm/svm_struct/Makefile	/^LD = gcc$/;"	m
LDFLAGS	svm/Makefile	/^LDFLAGS =  $(SFLAGS) -O3 -lm -Wall$/;"	m
LDFLAGS	svm/svm_struct/Makefile	/^LDFLAGS =   $(SFLAGS) -O3 -lm -Wall$/;"	m
LEARN_PARM	svm/svm_light/svm_common.h	/^} LEARN_PARM;$/;"	t	typeref:struct:learn_parm
LFLAGS	svm/svm_light/Makefile	/^LFLAGS=  $(SFLAGS) -O3                     # release linker flags$/;"	m
LIBS	svm/svm_light/Makefile	/^LIBS=-L. -lm                               # used libraries$/;"	m
LINEAR	svm/svm_light/svm_common.h	43;"	d
MARGIN_RESCALING	svm/svm_struct/svm_struct_learn.h	36;"	d
MATRIX	svm/svm_light/svm_common.h	/^} MATRIX;$/;"	t	typeref:struct:matrix
MAX	svm/svm_light/svm_common.c	23;"	d	file:
MAX	svm/svm_light/svm_learn.c	23;"	d	file:
MAX	svm/svm_struct/svm_struct_learn.c	26;"	d	file:
MAXFEATNUM	svm/svm_light/svm_common.h	40;"	d
MAXITER_EXCEEDED	svm/svm_light/svm_hideo.c	38;"	d	file:
MAXSHRINK	svm/svm_light/svm_common.h	55;"	d
MIN	svm/svm_light/svm_common.c	24;"	d	file:
MIN	svm/svm_light/svm_learn.c	24;"	d	file:
MIN	svm/svm_struct/svm_struct_learn.c	27;"	d	file:
MODEL	svm/svm_light/svm_common.h	/^} MODEL;$/;"	t	typeref:struct:model
NAN_SOLUTION	svm/svm_light/svm_hideo.c	39;"	d	file:
NSLACK_ALG	svm/svm_struct/svm_struct_learn.h	38;"	d
NSLACK_SHRINK_ALG	svm/svm_struct/svm_struct_learn.h	39;"	d
ONESLACK_DUAL_ALG	svm/svm_struct/svm_struct_learn.h	41;"	d
ONESLACK_DUAL_CACHE_ALG	svm/svm_struct/svm_struct_learn.h	42;"	d
ONESLACK_PRIMAL_ALG	svm/svm_struct/svm_struct_learn.h	40;"	d
ONLY_ONE_VARIABLE	svm/svm_light/svm_hideo.c	40;"	d	file:
OPTIMIZATION	svm/svm_light/svm_common.h	53;"	d
PATTERN	svm/svm_struct_api_types.h	/^} PATTERN;$/;"	t	typeref:struct:pattern
POLY	svm/svm_light/svm_common.h	44;"	d
PRIMAL_OPTIMAL	svm/svm_light/svm_hideo.c	36;"	d	file:
QP	svm/svm_light/svm_common.h	/^} QP;$/;"	t	typeref:struct:quadratic_program
RANDPAIR	svm/svm_light/svm_common.h	/^} RANDPAIR;$/;"	t	typeref:struct:randpair
RANKING	svm/svm_light/svm_common.h	52;"	d
RBF	svm/svm_light/svm_common.h	45;"	d
REGRESSION	svm/svm_light/svm_common.h	51;"	d
SAMPLE	svm/svm_struct/svm_struct_common.h	/^} SAMPLE;$/;"	t	typeref:struct:sample
SHRINK_STATE	svm/svm_light/svm_common.h	/^} SHRINK_STATE;$/;"	t	typeref:struct:shrink_state
SIGMOID	svm/svm_light/svm_common.h	46;"	d
SIGN	svm/svm_light/svm_common.c	25;"	d	file:
SIGN	svm/svm_light/svm_learn.c	25;"	d	file:
SLACK_RESCALING	svm/svm_struct/svm_struct_learn.h	35;"	d
SMALLROUND	svm/svm_light/svm_hideo.c	43;"	d	file:
STRUCTMODEL	svm/svm_struct_api_types.h	/^} STRUCTMODEL;$/;"	t	typeref:struct:structmodel
STRUCT_LEARN_PARM	svm/svm_struct_api_types.h	/^} STRUCT_LEARN_PARM;$/;"	t	typeref:struct:struct_learn_parm
STRUCT_TEST_STATS	svm/svm_struct_api_types.h	/^} STRUCT_TEST_STATS;$/;"	t	typeref:struct:struct_test_stats
STRUCT_VERSION	svm/svm_struct/svm_struct_common.h	22;"	d
STRUCT_VERSION_DATE	svm/svm_struct/svm_struct_common.h	23;"	d
SVECTOR	svm/svm_light/svm_common.h	/^} SVECTOR;$/;"	t	typeref:struct:svector
SVM_COMMON	svm/svm_light/svm_common.h	20;"	d
SVM_LEARN	svm/svm_light/svm_learn.h	20;"	d
SVM_STRUCT_LEARN	svm/svm_struct/svm_struct_learn.h	22;"	d
TIMING	svm/svm_light/svm_common.h	/^} TIMING;$/;"	t	typeref:struct:timing_profile
USE_FYCACHE	svm/svm_struct_api_types.h	39;"	d
VERSION	svm/svm_light/svm_common.h	31;"	d
VERSION_DATE	svm/svm_light/svm_common.h	32;"	d
WORD	svm/svm_light/svm_common.h	/^} WORD;$/;"	t	typeref:struct:word
a_history	svm/svm_light/svm_common.h	/^  double **a_history;  \/* for shrinking with non-linear kernel *\/$/;"	m	struct:shrink_state
active	svm/svm_light/svm_common.h	/^  long   *active;$/;"	m	struct:shrink_state
active2totdoc	svm/svm_light/svm_common.h	/^  long   *active2totdoc;$/;"	m	struct:kernel_cache
activenum	svm/svm_light/svm_common.h	/^  long   activenum;$/;"	m	struct:kernel_cache
add_constraint_to_constraint_cache	svm/svm_struct/svm_struct_learn.c	/^double add_constraint_to_constraint_cache(CCACHE *ccache, MODEL *svmModel, int exnum, SVECTOR *fydelta, double rhs, double gainthresh, int maxconst, double *rt_cachesum)$/;"	f
add_dual_list_ns_r	svm/svm_light/svm_common.c	/^SVECTOR* add_dual_list_ns_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_dual_list_sort_ss_r	svm/svm_light/svm_common.c	/^SVECTOR* add_dual_list_sort_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_dual_list_ss_r	svm/svm_light/svm_common.c	/^SVECTOR* add_dual_list_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_list_n_ns	svm/svm_light/svm_common.c	/^void add_list_n_ns(double *vec_n, SVECTOR *vec_s, double faktor)$/;"	f
add_list_ns	svm/svm_light/svm_common.c	/^SVECTOR* add_list_ns(SVECTOR *a)$/;"	f
add_list_ns_r	svm/svm_light/svm_common.c	/^SVECTOR* add_list_ns_r(SVECTOR *a, double min_non_zero) $/;"	f
add_list_sort_ss	svm/svm_light/svm_common.c	/^SVECTOR* add_list_sort_ss(SVECTOR *a) $/;"	f
add_list_sort_ss_r	svm/svm_light/svm_common.c	/^SVECTOR* add_list_sort_ss_r(SVECTOR *a, double min_non_zero) $/;"	f
add_list_ss	svm/svm_light/svm_common.c	/^SVECTOR* add_list_ss(SVECTOR *a) $/;"	f
add_list_ss_r	svm/svm_light/svm_common.c	/^SVECTOR* add_list_ss_r(SVECTOR *a, double min_non_zero) $/;"	f
add_ss	svm/svm_light/svm_common.c	/^SVECTOR* add_ss(SVECTOR *a, SVECTOR *b) $/;"	f
add_ss_r	svm/svm_light/svm_common.c	/^SVECTOR* add_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
add_to_index	svm/svm_light/svm_learn.c	/^void add_to_index(long int *index, long int elem)$/;"	f
add_vector_ns	svm/svm_light/svm_common.c	/^void add_vector_ns(double *vec_n, SVECTOR *vec_s, double faktor)$/;"	f
add_weight_vector_to_linear_model	svm/svm_light/svm_common.c	/^void add_weight_vector_to_linear_model(MODEL *model)$/;"	f
add_your_variables_here	svm/svm_struct_api_types.h	/^  int add_your_variables_here;$/;"	m	struct:label
add_your_variables_here	svm/svm_struct_api_types.h	/^  int add_your_variables_here;$/;"	m	struct:pattern
add_your_variables_here	svm/svm_struct_api_types.h	/^  int add_your_variables_here;$/;"	m	struct:struct_learn_parm
add_your_variables_here	svm/svm_struct_api_types.h	/^  int add_your_variables_here;$/;"	m	struct:structmodel
alpha	svm/svm_light/svm_common.h	/^  double  *alpha;$/;"	m	struct:model
alphafile	svm/svm_light/svm_common.h	/^  char alphafile[200];         \/* file to store optimal alphas in. use  $/;"	m	struct:learn_parm
append_svector_list	svm/svm_light/svm_common.c	/^void append_svector_list(SVECTOR *a, SVECTOR *b) $/;"	f
at_upper_bound	svm/svm_light/svm_common.h	/^  long    at_upper_bound;$/;"	m	struct:model
avg_viol_gain	svm/svm_struct/svm_struct_learn.h	/^  double  *avg_viol_gain; \/* array of average values by which$/;"	m	struct:ccache
b	svm/svm_light/svm_common.h	/^  double  b;$/;"	m	struct:model
batch_size	svm/svm_struct_api_types.h	/^  double batch_size;           \/* size of the mini batches in percent$/;"	m	struct:struct_learn_parm
biased_hyperplane	svm/svm_light/svm_common.h	/^  long   biased_hyperplane;    \/* if nonzero, use hyperplane w*x+b=0 $/;"	m	struct:learn_parm
buffer	svm/svm_light/svm_common.h	/^  CFLOAT *buffer; \/* to improve speed *\/$/;"	m	struct:kernel_cache
buffer	svm/svm_light/svm_hideo.c	/^double *buffer;$/;"	v
buffsize	svm/svm_light/svm_common.h	/^  long   buffsize;$/;"	m	struct:kernel_cache
cache	svm/svm_light/svm_learn.h	/^  CFLOAT *cache;$/;"	m	struct:cache_parm_s
cache_kernel_row	svm/svm_light/svm_learn.c	/^void cache_kernel_row(KERNEL_CACHE *kernel_cache, DOC **docs, $/;"	f
cache_multiple_kernel_rows	svm/svm_light/svm_learn.c	/^void cache_multiple_kernel_rows(KERNEL_CACHE *kernel_cache, DOC **docs, $/;"	f
cache_parm_s	svm/svm_light/svm_learn.h	/^typedef struct cache_parm_s {$/;"	s
cache_parm_t	svm/svm_light/svm_learn.h	/^} cache_parm_t;$/;"	t	typeref:struct:cache_parm_s
calculate_qp_objective	svm/svm_light/svm_hideo.c	/^double calculate_qp_objective(opt_n,opt_g,opt_g0,alpha)$/;"	f
calculate_svm_model	svm/svm_light/svm_learn.c	/^long calculate_svm_model(DOC **docs, long int *label, long int *unlabeled, $/;"	f
ccache	svm/svm_struct/svm_struct_learn.h	/^typedef struct ccache {$/;"	s
ccache_size	svm/svm_struct_api_types.h	/^  int    ccache_size;          \/* maximum number of constraints to$/;"	m	struct:struct_learn_parm
ccacheelem	svm/svm_struct/svm_struct_learn.h	/^typedef struct ccacheelem {$/;"	s
changed	svm/svm_struct/svm_struct_learn.h	/^  int     *changed;       \/* array of boolean indicating whether the$/;"	m	struct:ccache
check_learning_parms	svm/svm_light/svm_common.c	/^int check_learning_parms(LEARN_PARM *learn_parm, KERNEL_PARM *kernel_parm)$/;"	f
check_optimality	svm/svm_light/svm_learn.c	/^long check_optimality(MODEL *model, long int *label, long int *unlabeled, $/;"	f
check_optimality_sharedslack	svm/svm_light/svm_learn.c	/^long check_optimality_sharedslack(DOC **docs, MODEL *model, long int *label,$/;"	f
cholesky_matrix	svm/svm_light/svm_common.c	/^MATRIX *cholesky_matrix(MATRIX *A)$/;"	f
classify_example	svm/svm_light/svm_common.c	/^double classify_example(MODEL *model, DOC *ex) $/;"	f
classify_example_linear	svm/svm_light/svm_common.c	/^double classify_example_linear(MODEL *model, DOC *ex) $/;"	f
classify_struct_example	svm/svm_struct_api.c	/^LABEL       classify_struct_example(PATTERN x, STRUCTMODEL *sm, $/;"	f
clear_index	svm/svm_light/svm_learn.c	/^void clear_index(long int *index)$/;"	f
clear_nvector	svm/svm_light/svm_common.c	/^void clear_nvector(double *vec, long int n)$/;"	f
coef_const	svm/svm_light/svm_common.h	/^  double  coef_const;$/;"	m	struct:kernel_parm
coef_lin	svm/svm_light/svm_common.h	/^  double  coef_lin;$/;"	m	struct:kernel_parm
compact_linear_model	svm/svm_light/svm_common.c	/^MODEL *compact_linear_model(MODEL *model)$/;"	f
compare_randpair	svm/svm_light/svm_common.c	/^int compare_randpair(const void *a, const void *b) $/;"	f
compareup_word	svm/svm_light/svm_common.c	/^int compareup_word(const void *a, const void *b) $/;"	f
compute_index	svm/svm_light/svm_learn.c	/^long compute_index(long int *binfeature, long int range, long int *index)$/;"	f
compute_loo	svm/svm_light/svm_common.h	/^  long   compute_loo;          \/* if nonzero, computes leave-one-out$/;"	m	struct:learn_parm
compute_matrices_for_optimization	svm/svm_light/svm_learn.c	/^void compute_matrices_for_optimization(DOC **docs, long int *label, $/;"	f
compute_objective_function	svm/svm_light/svm_learn.c	/^double compute_objective_function(double *a, double *lin, double *c, $/;"	f
compute_shared_slacks	svm/svm_light/svm_learn.c	/^void compute_shared_slacks(DOC **docs, long int *label, $/;"	f
compute_violation_of_constraint_in_cache	svm/svm_struct/svm_struct_learn.c	/^double compute_violation_of_constraint_in_cache(CCACHE *ccache, double thresh)$/;"	f
compute_xa_estimates	svm/svm_light/svm_learn.c	/^void compute_xa_estimates(MODEL *model, long int *label, $/;"	f
constlist	svm/svm_struct/svm_struct_learn.h	/^  CCACHEELEM **constlist;    \/* array of pointers to constraint lists$/;"	m	struct:ccache
constset	svm/svm_struct/svm_struct_common.h	/^typedef struct constset { \/* a set of linear inequality constrains of$/;"	s
copy_matrix	svm/svm_light/svm_common.c	/^MATRIX *copy_matrix(MATRIX *matrix)$/;"	f
copy_model	svm/svm_light/svm_common.c	/^MODEL *copy_model(MODEL *model)$/;"	f
copy_svector	svm/svm_light/svm_common.c	/^SVECTOR *copy_svector(SVECTOR *vec)$/;"	f
copy_svector_shallow	svm/svm_light/svm_common.c	/^SVECTOR *copy_svector_shallow(SVECTOR *vec)$/;"	f
copyright_notice	svm/svm_light/svm_common.c	/^void copyright_notice(void)$/;"	f
costfactor	svm/svm_light/svm_common.h	/^  double  costfactor;          \/* Scales the cost of misclassifying this$/;"	m	struct:doc
create_constraint_cache	svm/svm_struct/svm_struct_learn.c	/^CCACHE *create_constraint_cache(SAMPLE sample, STRUCT_LEARN_PARM *sparm, $/;"	f
create_example	svm/svm_light/svm_common.c	/^DOC *create_example(long docnum, long queryid, long slackid, $/;"	f
create_matrix	svm/svm_light/svm_common.c	/^MATRIX *create_matrix(int n, int m)$/;"	f
create_nvector	svm/svm_light/svm_common.c	/^double *create_nvector(int n)$/;"	f
create_svector	svm/svm_light/svm_common.c	/^SVECTOR *create_svector(WORD *words,char *userdefined,double factor)$/;"	f
create_svector_n	svm/svm_light/svm_common.c	/^SVECTOR *create_svector_n(double *nonsparsevec, long maxfeatnum, char *userdefined, double factor)$/;"	f
create_svector_n_r	svm/svm_light/svm_common.c	/^SVECTOR *create_svector_n_r(double *nonsparsevec, long maxfeatnum, char *userdefined, double factor, double min_non_zero)$/;"	f
create_svector_shallow	svm/svm_light/svm_common.c	/^SVECTOR *create_svector_shallow(WORD *words,char *userdefined,double factor)$/;"	f
custom	svm/svm_light/svm_common.h	/^  char    custom[50];    \/* for user supplied kernel *\/$/;"	m	struct:kernel_parm
custom_argc	svm/svm_struct_api_types.h	/^  int    custom_argc;          \/* number of --* command line options *\/$/;"	m	struct:struct_learn_parm
custom_argv	svm/svm_struct_api_types.h	/^  char   custom_argv[50][300]; \/* storage for the --* command line options *\/$/;"	m	struct:struct_learn_parm
custom_kernel	svm/svm_light/kernel.h	/^double custom_kernel(KERNEL_PARM *kernel_parm, SVECTOR *a, SVECTOR *b) $/;"	f
deactnum	svm/svm_light/svm_common.h	/^  long   deactnum;$/;"	m	struct:shrink_state
distribute_alpha_t_greedily	svm/svm_light/svm_learn.c	/^double distribute_alpha_t_greedily(long int *sv2dnum, long int svnum, $/;"	f
doc	svm/svm_light/svm_common.h	/^typedef struct doc {$/;"	s
docfile	svm/svm_light/svm_classify.c	/^char docfile[200];$/;"	v
docfile	svm/svm_light/svm_learn_main.c	/^char docfile[200];           \/* file with training examples *\/$/;"	v
docnum	svm/svm_light/svm_common.h	/^  long    docnum;              \/* Document ID. This has to be the position of $/;"	m	struct:doc
docs	svm/svm_light/svm_learn.h	/^  DOC **docs; $/;"	m	struct:cache_parm_s
dual	svm/svm_light/svm_hideo.c	/^double *primal=0,*dual=0;$/;"	v
dual	svm/svm_light/svm_loqo.c	/^double *primal=0,*dual=0;$/;"	v
element	svm/svm_light/svm_common.h	/^  double **element;$/;"	m	struct:matrix
elems	svm/svm_light/svm_common.h	/^  long   elems;$/;"	m	struct:kernel_cache
empty_label	svm/svm_struct_api.c	/^int         empty_label(LABEL y)$/;"	f
eps	svm/svm_light/svm_common.h	/^  double eps;                  \/* regression epsilon (eps=1.0 for$/;"	m	struct:learn_parm
epsilon	svm/svm_struct_api_types.h	/^  double epsilon;              \/* precision for which to solve$/;"	m	struct:struct_learn_parm
epsilon_a	svm/svm_light/svm_common.h	/^  double epsilon_a;            \/* tolerable error on alphas at bounds *\/$/;"	m	struct:learn_parm
epsilon_const	svm/svm_light/svm_common.h	/^  double epsilon_const;        \/* tolerable error on eq-constraint *\/$/;"	m	struct:learn_parm
epsilon_crit	svm/svm_light/svm_common.h	/^  double epsilon_crit;         \/* tolerable error for distances used $/;"	m	struct:learn_parm
epsilon_shrink	svm/svm_light/svm_common.h	/^  double epsilon_shrink;       \/* how much a multiplier should be above $/;"	m	struct:learn_parm
estimate_margin_vcdim	svm/svm_light/svm_learn.c	/^double estimate_margin_vcdim(MODEL *model, double w, double R) $/;"	f
estimate_r_delta	svm/svm_light/svm_learn.c	/^double estimate_r_delta(DOC **docs, long int totdoc, KERNEL_PARM *kernel_parm)$/;"	f
estimate_r_delta_average	svm/svm_light/svm_learn.c	/^double estimate_r_delta_average(DOC **docs, long int totdoc, $/;"	f
estimate_sphere	svm/svm_light/svm_learn.c	/^double estimate_sphere(MODEL *model) $/;"	f
estimate_transduction_quality	svm/svm_light/svm_learn.c	/^void estimate_transduction_quality(MODEL *model, long int *label, $/;"	f
eval_prediction	svm/svm_struct_api.c	/^void        eval_prediction(long exnum, EXAMPLE ex, LABEL ypred, $/;"	f
example	svm/svm_struct/svm_struct_common.h	/^typedef struct example {  \/* an example is a pair of pattern and label *\/$/;"	s
examples	svm/svm_struct/svm_struct_common.h	/^  EXAMPLE *examples;$/;"	m	struct:sample
factor	svm/svm_light/svm_common.h	/^  double  factor;              \/* Factor by which this feature vector$/;"	m	struct:svector
featvec_eq	svm/svm_light/svm_common.c	/^int featvec_eq(SVECTOR *a, SVECTOR *b)$/;"	f
finalize_iteration	svm/svm_struct_api.c	/^int         finalize_iteration(double ceps, int cached_constraint,$/;"	f
find_indep_subset_of_matrix	svm/svm_light/svm_common.c	/^double *find_indep_subset_of_matrix(MATRIX *A, double epsilon)$/;"	f
find_most_violated_constraint	svm/svm_struct/svm_struct_learn.c	/^void find_most_violated_constraint(SVECTOR **fydelta, double *rhs, $/;"	f
find_most_violated_constraint_marginrescaling	svm/svm_struct_api.c	/^LABEL       find_most_violated_constraint_marginrescaling(PATTERN x, LABEL y, $/;"	f
find_most_violated_constraint_slackrescaling	svm/svm_struct_api.c	/^LABEL       find_most_violated_constraint_slackrescaling(PATTERN x, LABEL y, $/;"	f
find_most_violated_joint_constraint_in_cache	svm/svm_struct/svm_struct_learn.c	/^double find_most_violated_joint_constraint_in_cache(CCACHE *ccache, double thresh, double *lhs_n, SVECTOR **lhs, double *rhs)$/;"	f
free_constraint_cache	svm/svm_struct/svm_struct_learn.c	/^void free_constraint_cache(CCACHE *ccache)$/;"	f
free_example	svm/svm_light/svm_common.c	/^void free_example(DOC *example, long deep)$/;"	f
free_label	svm/svm_struct_api.c	/^void        free_label(LABEL y) {$/;"	f
free_matrix	svm/svm_light/svm_common.c	/^void free_matrix(MATRIX *matrix) $/;"	f
free_model	svm/svm_light/svm_common.c	/^void free_model(MODEL *model, int deep)$/;"	f
free_nvector	svm/svm_light/svm_common.c	/^void free_nvector(double *vector) $/;"	f
free_pattern	svm/svm_struct_api.c	/^void        free_pattern(PATTERN x) {$/;"	f
free_struct_model	svm/svm_struct_api.c	/^void        free_struct_model(STRUCTMODEL sm) $/;"	f
free_struct_sample	svm/svm_struct_api.c	/^void        free_struct_sample(SAMPLE s)$/;"	f
free_svector	svm/svm_light/svm_common.c	/^void free_svector(SVECTOR *vec)$/;"	f
free_svector_shallow	svm/svm_light/svm_common.c	/^void free_svector_shallow(SVECTOR *vec)$/;"	f
fvec	svm/svm_light/svm_common.h	/^  SVECTOR *fvec;               \/* Feature vector of the example. The$/;"	m	struct:doc
fydelta	svm/svm_struct/svm_struct_learn.h	/^  SVECTOR *fydelta; \/* left hand side of constraint *\/$/;"	m	struct:ccacheelem
get_kernel_row	svm/svm_light/svm_learn.c	/^void get_kernel_row(KERNEL_CACHE *kernel_cache, DOC **docs, $/;"	f
get_runtime	svm/svm_light/svm_common.c	/^double get_runtime(void)$/;"	f
gram_matrix	svm/svm_light/svm_common.h	/^  MATRIX  *gram_matrix;  \/* here one can directly supply the kernel$/;"	m	struct:kernel_parm
identify_inconsistent	svm/svm_light/svm_learn.c	/^long identify_inconsistent(double *a, long int *label, $/;"	f
identify_misclassified	svm/svm_light/svm_learn.c	/^long identify_misclassified(double *lin, long int *label, $/;"	f
identify_one_misclassified	svm/svm_light/svm_learn.c	/^long identify_one_misclassified(double *lin, long int *label, $/;"	f
inactive_since	svm/svm_light/svm_common.h	/^  long   *inactive_since;$/;"	m	struct:shrink_state
incorporate_unlabeled_examples	svm/svm_light/svm_learn.c	/^long incorporate_unlabeled_examples(MODEL *model, long int *label, $/;"	f
index	svm/svm_light/svm_common.h	/^  long    *index;       \/* index from docnum to position in model *\/$/;"	m	struct:model
index	svm/svm_light/svm_common.h	/^  long   *index;  \/* cache some kernel evalutations *\/$/;"	m	struct:kernel_cache
init_iter	svm/svm_light/svm_loqo.c	/^long   init_iter=500,precision_violations=0;$/;"	v
init_kernel_matrix	svm/svm_struct/svm_struct_learn.c	/^MATRIX *init_kernel_matrix(CONSTSET *cset, KERNEL_PARM *kparm) $/;"	f
init_margin	svm/svm_light/svm_loqo.c	/^double init_margin=0.15;$/;"	v
init_shrink_state	svm/svm_light/svm_learn.c	/^void init_shrink_state(SHRINK_STATE *shrink_state, long int totdoc, $/;"	f
init_struct_constraints	svm/svm_struct_api.c	/^CONSTSET    init_struct_constraints(SAMPLE sample, STRUCTMODEL *sm, $/;"	f
init_struct_model	svm/svm_struct_api.c	/^void        init_struct_model(SAMPLE sample, STRUCTMODEL *sm, $/;"	f
invert_ltriangle_matrix	svm/svm_light/svm_common.c	/^MATRIX *invert_ltriangle_matrix(MATRIX *L)$/;"	f
invindex	svm/svm_light/svm_common.h	/^  long   *invindex;$/;"	m	struct:kernel_cache
isnan	svm/svm_light/svm_common.c	/^int isnan(double a)$/;"	f
kernel	svm/svm_light/svm_common.c	/^double kernel(KERNEL_PARM *kernel_parm, DOC *a, DOC *b) $/;"	f
kernel_cache	svm/svm_light/svm_common.h	/^typedef struct kernel_cache {$/;"	s
kernel_cache	svm/svm_light/svm_learn.h	/^  KERNEL_CACHE *kernel_cache;$/;"	m	struct:cache_parm_s
kernel_cache_check	svm/svm_light/svm_learn.c	/^long kernel_cache_check(KERNEL_CACHE *kernel_cache, long int docnum)$/;"	f
kernel_cache_clean_and_malloc	svm/svm_light/svm_learn.c	/^CFLOAT *kernel_cache_clean_and_malloc(KERNEL_CACHE *kernel_cache, $/;"	f
kernel_cache_cleanup	svm/svm_light/svm_learn.c	/^void kernel_cache_cleanup(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_free	svm/svm_light/svm_learn.c	/^void kernel_cache_free(KERNEL_CACHE *kernel_cache, long int i)$/;"	f
kernel_cache_free_lru	svm/svm_light/svm_learn.c	/^long kernel_cache_free_lru(KERNEL_CACHE *kernel_cache) $/;"	f
kernel_cache_init	svm/svm_light/svm_learn.c	/^KERNEL_CACHE *kernel_cache_init(long int totdoc, long int buffsize)$/;"	f
kernel_cache_malloc	svm/svm_light/svm_learn.c	/^long kernel_cache_malloc(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_reset_lru	svm/svm_light/svm_learn.c	/^void kernel_cache_reset_lru(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_shrink	svm/svm_light/svm_learn.c	/^void kernel_cache_shrink(KERNEL_CACHE *kernel_cache, long int totdoc, $/;"	f
kernel_cache_size	svm/svm_light/svm_common.h	/^  long   kernel_cache_size;    \/* size of kernel cache in megabytes *\/$/;"	m	struct:learn_parm
kernel_cache_space_available	svm/svm_light/svm_learn.c	/^long kernel_cache_space_available(KERNEL_CACHE *kernel_cache)$/;"	f
kernel_cache_statistic	svm/svm_light/svm_common.c	/^long   kernel_cache_statistic;$/;"	v
kernel_cache_touch	svm/svm_light/svm_learn.c	/^long kernel_cache_touch(KERNEL_CACHE *kernel_cache, long int docnum)$/;"	f
kernel_id	svm/svm_light/svm_common.h	/^  long    kernel_id;           \/* Feature vectors with different$/;"	m	struct:svector
kernel_parm	svm/svm_light/svm_common.h	/^  KERNEL_PARM kernel_parm; \/* kernel *\/$/;"	m	struct:model
kernel_parm	svm/svm_light/svm_common.h	/^typedef struct kernel_parm {$/;"	s
kernel_parm	svm/svm_light/svm_learn.h	/^  KERNEL_PARM *kernel_parm;$/;"	m	struct:cache_parm_s
kernel_type	svm/svm_light/svm_common.h	/^  long    kernel_type;   \/* 0=linear, 1=poly, 2=rbf, 3=sigmoid,$/;"	m	struct:kernel_parm
kernelid	svm/svm_light/svm_common.h	/^  long    kernelid;            \/* Position in gram matrix where kernel$/;"	m	struct:doc
label	svm/svm_struct_api_types.h	/^typedef struct label {$/;"	s
ladd_matrix	svm/svm_light/svm_hideo.c	/^void ladd_matrix(matrix,depth,scalar)$/;"	f
last_a	svm/svm_light/svm_common.h	/^  double *last_a;      \/* for shrinking with linear kernel *\/$/;"	m	struct:shrink_state
last_lin	svm/svm_light/svm_common.h	/^  double *last_lin;    \/* for shrinking with linear kernel *\/$/;"	m	struct:shrink_state
lcopy_matrix	svm/svm_light/svm_hideo.c	/^void lcopy_matrix(matrix,depth,matrix2) $/;"	f
learn_parm	svm/svm_light/svm_common.h	/^typedef struct learn_parm {$/;"	s
length_of_longest_document_vector	svm/svm_light/svm_learn.c	/^double length_of_longest_document_vector(DOC **docs, long int totdoc, $/;"	f
lhs	svm/svm_struct/svm_struct_common.h	/^  DOC     **lhs;$/;"	m	struct:constset
lin_weights	svm/svm_light/svm_common.h	/^  double  *lin_weights;                       \/* weights for linear case using$/;"	m	struct:model
lindep_sensitivity	svm/svm_light/svm_hideo.c	/^double lindep_sensitivity=DEF_LINDEP_SENSITIVITY;$/;"	v
linvert_matrix	svm/svm_light/svm_hideo.c	/^void linvert_matrix(matrix,depth,inverse,lindep_sensitivity,lin_dependent)$/;"	f
loo_error	svm/svm_light/svm_common.h	/^  double  loo_error,loo_recall,loo_precision; \/* leave-one-out estimates *\/$/;"	m	struct:model
loo_precision	svm/svm_light/svm_common.h	/^  double  loo_error,loo_recall,loo_precision; \/* leave-one-out estimates *\/$/;"	m	struct:model
loo_recall	svm/svm_light/svm_common.h	/^  double  loo_error,loo_recall,loo_precision; \/* leave-one-out estimates *\/$/;"	m	struct:model
loss	svm/svm_struct_api.c	/^double      loss(LABEL y, LABEL ybar, STRUCT_LEARN_PARM *sparm)$/;"	f
loss_function	svm/svm_struct_api_types.h	/^  int    loss_function;        \/* select between different loss$/;"	m	struct:struct_learn_parm
loss_type	svm/svm_struct_api_types.h	/^  int    loss_type;            \/* selected loss type from -r$/;"	m	struct:struct_learn_parm
lprint_matrix	svm/svm_light/svm_hideo.c	/^void lprint_matrix(matrix,depth)$/;"	f
lru	svm/svm_light/svm_common.h	/^  long   *lru;$/;"	m	struct:kernel_cache
lswitch_rows_matrix	svm/svm_light/svm_hideo.c	/^void lswitch_rows_matrix(matrix,depth,r1,r2) $/;"	f
lswitchrk_matrix	svm/svm_light/svm_hideo.c	/^void lswitchrk_matrix(matrix,depth,rk1,rk2) $/;"	f
m	svm/svm_light/svm_common.h	/^  int m; \/* number of colums *\/$/;"	m	struct:matrix
m	svm/svm_light/svm_learn.h	/^  long m;$/;"	m	struct:cache_parm_s
m	svm/svm_struct/svm_struct_common.h	/^  int     m;            \/* m is the total number of constrains *\/$/;"	m	struct:constset
main	svm/svm_light/svm_classify.c	/^int main (int argc, char* argv[])$/;"	f
main	svm/svm_light/svm_learn_main.c	/^int main (int argc, char* argv[])$/;"	f
main	svm/svm_struct/svm_struct_classify.c	/^int main (int argc, char* argv[])$/;"	f
main	svm/svm_struct/svm_struct_main.c	/^int main (int argc, char* argv[])$/;"	f
matrix	svm/svm_light/svm_common.h	/^typedef struct matrix {$/;"	s
max_elems	svm/svm_light/svm_common.h	/^  long   max_elems;$/;"	m	struct:kernel_cache
maxdiff	svm/svm_light/svm_common.h	/^  double  maxdiff;                            \/* precision, up to which this $/;"	m	struct:model
maxhistory	svm/svm_light/svm_common.h	/^  long   maxhistory;$/;"	m	struct:shrink_state
maxiter	svm/svm_light/svm_common.h	/^  long   maxiter;              \/* number of iterations after which the$/;"	m	struct:learn_parm
maxiter	svm/svm_light/svm_hideo.c	/^long   maxiter=DEF_MAX_ITERATIONS;$/;"	v
maxl	svm/svm_light/svm_common.c	/^long maxl(long int a, long int b)$/;"	f
minl	svm/svm_light/svm_common.c	/^long minl(long int a, long int b)$/;"	f
model	svm/svm_light/svm_common.h	/^typedef struct model {$/;"	s
model_b	svm/svm_light/svm_loqo.c	/^double model_b;$/;"	v
model_length_n	svm/svm_light/svm_common.c	/^double model_length_n(MODEL *model) $/;"	f
model_length_s	svm/svm_light/svm_common.c	/^double model_length_s(MODEL *model) $/;"	f
modelfile	svm/svm_light/svm_classify.c	/^char modelfile[200];$/;"	v
modelfile	svm/svm_light/svm_learn_main.c	/^char modelfile[200];         \/* file for resulting classifier *\/$/;"	v
modelfile	svm/svm_struct/svm_struct_classify.c	/^char modelfile[200];$/;"	v
modelfile	svm/svm_struct/svm_struct_main.c	/^char modelfile[200];           \/* file for resulting classifier *\/$/;"	v
mult_svector_list	svm/svm_light/svm_common.c	/^void mult_svector_list(SVECTOR *a, double factor) $/;"	f
mult_vector_ns	svm/svm_light/svm_common.c	/^void mult_vector_ns(double *vec_n, SVECTOR *vec_s, double faktor)$/;"	f
multadd_ss	svm/svm_light/svm_common.c	/^SVECTOR* multadd_ss(SVECTOR *a, SVECTOR *b, double fa, double fb)$/;"	f
multadd_ss_r	svm/svm_light/svm_common.c	/^SVECTOR* multadd_ss_r(SVECTOR *a,SVECTOR *b,double fa, double fb,$/;"	f
my_malloc	svm/svm_light/svm_common.c	/^void *my_malloc(size_t size)$/;"	f
n	svm/svm_light/svm_common.h	/^  int n; \/* number of rows *\/$/;"	m	struct:matrix
n	svm/svm_struct/svm_struct_common.h	/^  int     n;            \/* n is the total number of examples *\/$/;"	m	struct:sample
n	svm/svm_struct/svm_struct_learn.h	/^  int        n;              \/* number of examples *\/$/;"	m	struct:ccache
newconstretrain	svm/svm_struct_api_types.h	/^  double newconstretrain;      \/* number of new constraints to$/;"	m	struct:struct_learn_parm
next	svm/svm_light/svm_common.h	/^  struct svector *next;        \/* Let's you set up a list of SVECTOR's$/;"	m	struct:svector	typeref:struct:svector::svector
next	svm/svm_struct/svm_struct_learn.h	/^  struct ccacheelem *next; \/* next in linked list *\/$/;"	m	struct:ccacheelem	typeref:struct:ccacheelem::ccacheelem
nol_ll	svm/svm_light/svm_common.c	/^void nol_ll(char *file, long int *nol, long int *wol, long int *ll) $/;"	f
nonoptimal	svm/svm_light/svm_hideo.c	/^long   *nonoptimal;$/;"	v
occu	svm/svm_light/svm_common.h	/^  long   *occu;$/;"	m	struct:kernel_cache
offset	svm/svm_light/svm_learn.h	/^  long offset,stepsize;$/;"	m	struct:cache_parm_s
opt_ce	svm/svm_light/svm_common.h	/^  double *opt_ce,*opt_ce0; \/* linear equality constraints $/;"	m	struct:quadratic_program
opt_ce0	svm/svm_light/svm_common.h	/^  double *opt_ce,*opt_ce0; \/* linear equality constraints $/;"	m	struct:quadratic_program
opt_g	svm/svm_light/svm_common.h	/^  double *opt_g;           \/* hessian of objective *\/$/;"	m	struct:quadratic_program
opt_g0	svm/svm_light/svm_common.h	/^  double *opt_g0;          \/* linear part of objective *\/$/;"	m	struct:quadratic_program
opt_low	svm/svm_light/svm_common.h	/^  double *opt_low,*opt_up; \/* box constraints *\/$/;"	m	struct:quadratic_program
opt_m	svm/svm_light/svm_common.h	/^  long   opt_m;            \/* number of linear equality constraints *\/$/;"	m	struct:quadratic_program
opt_n	svm/svm_light/svm_common.h	/^  long   opt_n;            \/* number of variables *\/$/;"	m	struct:quadratic_program
opt_precision	svm/svm_light/svm_common.h	/^  double opt_precision;        \/* precision of solver, set to e.g. 1e-21 $/;"	m	struct:learn_parm
opt_precision	svm/svm_light/svm_hideo.c	/^double opt_precision=DEF_PRECISION;$/;"	v
opt_precision	svm/svm_light/svm_loqo.c	/^double opt_precision=DEF_PRECISION_LINEAR;$/;"	v
opt_up	svm/svm_light/svm_common.h	/^  double *opt_low,*opt_up; \/* box constraints *\/$/;"	m	struct:quadratic_program
opt_xinit	svm/svm_light/svm_common.h	/^  double *opt_xinit;       \/* initial value for variables *\/$/;"	m	struct:quadratic_program
optimize_hildreth_despo	svm/svm_light/svm_hideo.c	/^int optimize_hildreth_despo(n,m,precision,epsilon_crit,epsilon_a,maxiter,goal,$/;"	f
optimize_qp	svm/svm_light/svm_hideo.c	/^double *optimize_qp(qp,epsilon_crit,nx,threshold,learn_parm)$/;"	f
optimize_qp	svm/svm_light/svm_loqo.c	/^double *optimize_qp(qp,epsilon_crit,nx,threshold,learn_parm)$/;"	f
optimize_svm	svm/svm_light/svm_learn.c	/^void optimize_svm(DOC **docs, long int *label, long int *unlabeled, $/;"	f
optimize_to_convergence	svm/svm_light/svm_learn.c	/^long optimize_to_convergence(DOC **docs, long int *label, long int totdoc, $/;"	f
optimize_to_convergence_sharedslack	svm/svm_light/svm_learn.c	/^long optimize_to_convergence_sharedslack(DOC **docs, long int *label, $/;"	f
parse_document	svm/svm_light/svm_common.c	/^int parse_document(char *line, WORD *words, double *label,$/;"	f
parse_struct_parameters	svm/svm_struct_api.c	/^void         parse_struct_parameters(STRUCT_LEARN_PARM *sparm)$/;"	f
parse_struct_parameters_classify	svm/svm_struct_api.c	/^void         parse_struct_parameters_classify(STRUCT_LEARN_PARM *sparm)$/;"	f
pattern	svm/svm_struct_api_types.h	/^typedef struct pattern {$/;"	s
poly_degree	svm/svm_light/svm_common.h	/^  long    poly_degree;$/;"	m	struct:kernel_parm
precision_violations	svm/svm_light/svm_hideo.c	/^long   precision_violations=0;$/;"	v
precision_violations	svm/svm_light/svm_loqo.c	/^long   init_iter=500,precision_violations=0;$/;"	v
predfile	svm/svm_light/svm_common.h	/^  char predfile[200];          \/* file for predicitions on unlabeled examples$/;"	m	struct:learn_parm
predictionsfile	svm/svm_light/svm_classify.c	/^char predictionsfile[200];$/;"	v
predictionsfile	svm/svm_struct/svm_struct_classify.c	/^char predictionsfile[200];$/;"	v
primal	svm/svm_light/svm_hideo.c	/^double *primal=0,*dual=0;$/;"	v
primal	svm/svm_light/svm_loqo.c	/^double *primal=0,*dual=0;$/;"	v
printDoubleArray	svm/svm_struct/svm_struct_common.c	/^void printDoubleArray(double* x, int n)$/;"	f
printIntArray	svm/svm_struct/svm_struct_common.c	/^void printIntArray(int* x, int n)$/;"	f
printW	svm/svm_struct/svm_struct_common.c	/^void printW(double *w, long sizePhi, long n,double C)$/;"	f
printWordArray	svm/svm_struct/svm_struct_common.c	/^void printWordArray(WORD* x)$/;"	f
print_help	svm/svm_light/svm_classify.c	/^void print_help(void)$/;"	f
print_help	svm/svm_light/svm_learn_main.c	/^void print_help()$/;"	f
print_help	svm/svm_struct/svm_struct_classify.c	/^void print_help(void)$/;"	f
print_help	svm/svm_struct/svm_struct_main.c	/^void print_help()$/;"	f
print_matrix	svm/svm_light/svm_common.c	/^void print_matrix(MATRIX *matrix)$/;"	f
print_percent_progress	svm/svm_light/svm_common.c	/^void print_percent_progress(long *progress, long maximum, $/;"	f
print_struct_help	svm/svm_struct_api.c	/^void        print_struct_help()$/;"	f
print_struct_help_classify	svm/svm_struct_api.c	/^void        print_struct_help_classify()$/;"	f
print_struct_learning_stats	svm/svm_struct_api.c	/^void        print_struct_learning_stats(SAMPLE sample, STRUCTMODEL *sm,$/;"	f
print_struct_testing_stats	svm/svm_struct_api.c	/^void        print_struct_testing_stats(SAMPLE sample, STRUCTMODEL *sm,$/;"	f
prod_ltmatrix_nvector	svm/svm_light/svm_common.c	/^double *prod_ltmatrix_nvector(MATRIX *A, double *v)$/;"	f
prod_matrix_matrix	svm/svm_light/svm_common.c	/^MATRIX *prod_matrix_matrix(MATRIX *A, MATRIX *B)$/;"	f
prod_matrix_nvector	svm/svm_light/svm_common.c	/^double *prod_matrix_nvector(MATRIX *A, double *v)$/;"	f
prod_nvector_ltmatrix	svm/svm_light/svm_common.c	/^double *prod_nvector_ltmatrix(double *v, MATRIX *A)$/;"	f
prod_nvector_matrix	svm/svm_light/svm_common.c	/^double *prod_nvector_matrix(double *v, MATRIX *A)$/;"	f
psi	svm/svm_struct_api.c	/^SVECTOR     *psi(PATTERN x, LABEL y, STRUCTMODEL *sm,$/;"	f
quadratic_program	svm/svm_light/svm_common.h	/^typedef struct quadratic_program {$/;"	s
queryid	svm/svm_light/svm_common.h	/^  long    queryid;             \/* for learning rankings, constraints are $/;"	m	struct:doc
random_order	svm/svm_light/svm_common.c	/^long *random_order(long n)$/;"	f
randpair	svm/svm_light/svm_common.h	/^typedef struct randpair {$/;"	s
rbf_gamma	svm/svm_light/svm_common.h	/^  double  rbf_gamma;$/;"	m	struct:kernel_parm
reactivate_inactive_examples	svm/svm_light/svm_learn.c	/^void reactivate_inactive_examples(long int *label, $/;"	f
read_alphas	svm/svm_light/svm_common.c	/^double *read_alphas(char *alphafile,long totdoc)$/;"	f
read_documents	svm/svm_light/svm_common.c	/^void read_documents(char *docfile, DOC ***docs, double **label, $/;"	f
read_image	data/bin2data.py	/^def read_image(filename):$/;"	f
read_image	data/bin2img.py	/^def read_image(filename, saveImage):$/;"	f
read_input_parameters	svm/svm_light/svm_classify.c	/^void read_input_parameters(int argc, char **argv, char *docfile, $/;"	f
read_input_parameters	svm/svm_light/svm_learn_main.c	/^void read_input_parameters(int argc,char *argv[],char *docfile,char *modelfile,$/;"	f
read_input_parameters	svm/svm_struct/svm_struct_classify.c	/^void read_input_parameters(int argc,char *argv[],char *testfile,$/;"	f
read_input_parameters	svm/svm_struct/svm_struct_main.c	/^void read_input_parameters(int argc,char *argv[],char *trainfile,$/;"	f
read_label	data/bin2data.py	/^def read_label(filename):$/;"	f
read_label	data/bin2img.py	/^def read_label(filename, saveFilename):$/;"	f
read_model	svm/svm_light/svm_common.c	/^MODEL *read_model(char *modelfile)$/;"	f
read_struct_examples	svm/svm_struct_api.c	/^SAMPLE      read_struct_examples(char *file, STRUCT_LEARN_PARM *sparm)$/;"	f
read_struct_model	svm/svm_struct_api.c	/^STRUCTMODEL read_struct_model(char *file, STRUCT_LEARN_PARM *sparm)$/;"	f
read_word	svm/svm_light/svm_common.c	/^int read_word(char *in, char *out) {$/;"	f
realloc_matrix	svm/svm_light/svm_common.c	/^MATRIX *realloc_matrix(MATRIX *matrix, int n, int m)$/;"	f
remove_inactive_constraints	svm/svm_struct/svm_struct_learn.c	/^void remove_inactive_constraints(CONSTSET *cset, double *alpha, $/;"	f
remove_inconsistent	svm/svm_light/svm_common.h	/^  long   remove_inconsistent;  \/* exclude examples with alpha at C and $/;"	m	struct:learn_parm
restartfile	svm/svm_light/svm_learn_main.c	/^char restartfile[200];       \/* file with initial alphas *\/$/;"	v
rho	svm/svm_light/svm_common.h	/^  double rho;                  \/* parameter in xi\/alpha-estimates and for$/;"	m	struct:learn_parm
rhs	svm/svm_struct/svm_struct_common.h	/^  double  *rhs;$/;"	m	struct:constset
rhs	svm/svm_struct/svm_struct_learn.h	/^  double  rhs;      \/* right hand side of constraint *\/$/;"	m	struct:ccacheelem
roundnumber	svm/svm_light/svm_hideo.c	/^long  roundnumber=0;$/;"	v
sample	svm/svm_struct/svm_struct_common.h	/^typedef struct sample { \/* a sample is a set of examples *\/$/;"	s
saveFile	data/bin2data.py	/^def saveFile(filename, images, labels):$/;"	f
select_next_qp_slackset	svm/svm_light/svm_learn.c	/^long select_next_qp_slackset(DOC **docs, long int *label, $/;"	f
select_next_qp_subproblem_grad	svm/svm_light/svm_learn.c	/^long select_next_qp_subproblem_grad(long int *label, $/;"	f
select_next_qp_subproblem_rand	svm/svm_light/svm_learn.c	/^long select_next_qp_subproblem_rand(long int *label, $/;"	f
select_top_n	svm/svm_light/svm_learn.c	/^void select_top_n(double *selcrit, long int range, long int *select, $/;"	f
set_learning_defaults	svm/svm_light/svm_common.c	/^void set_learning_defaults(LEARN_PARM *learn_parm, KERNEL_PARM *kernel_parm)$/;"	f
setfactor_svector_list	svm/svm_light/svm_common.c	/^void setfactor_svector_list(SVECTOR *a, double factor) $/;"	f
sharedslack	svm/svm_light/svm_common.h	/^  long   sharedslack;          \/* if nonzero, it will use the shared$/;"	m	struct:learn_parm
shift_s	svm/svm_light/svm_common.c	/^SVECTOR* shift_s(SVECTOR *a, long shift) $/;"	f
shrink_problem	svm/svm_light/svm_learn.c	/^long shrink_problem(DOC **docs,$/;"	f
shrink_state	svm/svm_light/svm_common.h	/^typedef struct shrink_state {$/;"	s
shrink_state_cleanup	svm/svm_light/svm_learn.c	/^void shrink_state_cleanup(SHRINK_STATE *shrink_state)$/;"	f
single_kernel	svm/svm_light/svm_common.c	/^double single_kernel(KERNEL_PARM *kernel_parm, SVECTOR *a, SVECTOR *b) $/;"	f
sizePsi	svm/svm_struct_api_types.h	/^  long   sizePsi;     \/* maximum number of weights in w *\/$/;"	m	struct:structmodel
skip_final_opt_check	svm/svm_light/svm_common.h	/^  long   skip_final_opt_check; \/* do not check KT-Conditions at the end of$/;"	m	struct:learn_parm
slack_norm	svm/svm_struct_api_types.h	/^  int    slack_norm;           \/* norm to use in objective function$/;"	m	struct:struct_learn_parm
slackid	svm/svm_light/svm_common.h	/^  long    slackid;             \/* Index of the slack variable$/;"	m	struct:doc
sm	svm/svm_struct/svm_struct_learn.h	/^  STRUCTMODEL *sm;           \/* pointer to model *\/$/;"	m	struct:ccache
smallroundcount	svm/svm_light/svm_hideo.c	/^long  smallroundcount=0;$/;"	v
smult_s	svm/svm_light/svm_common.c	/^SVECTOR* smult_s(SVECTOR *a, double factor) $/;"	f
solve_dual	svm/svm_light/svm_hideo.c	/^int solve_dual(n,m,precision,epsilon_crit,maxiter,g,g0,ce,ce0,low,up,primal,$/;"	f
sort	svm/svm_light/svm_common.h	/^  long   val,sort;$/;"	m	struct:randpair
space_or_null	svm/svm_light/svm_common.c	/^int space_or_null(int c) {$/;"	f
sprod_ns	svm/svm_light/svm_common.c	/^double sprod_ns(double *vec_n, SVECTOR *vec_s)$/;"	f
sprod_ss	svm/svm_light/svm_common.c	/^double sprod_ss(SVECTOR *a, SVECTOR *b) $/;"	f
stepsize	svm/svm_light/svm_learn.h	/^  long offset,stepsize;$/;"	m	struct:cache_parm_s
struct_learn_parm	svm/svm_struct_api_types.h	/^typedef struct struct_learn_parm {$/;"	s
struct_test_stats	svm/svm_struct_api_types.h	/^typedef struct struct_test_stats {$/;"	s
struct_verbosity	svm/svm_struct/svm_struct_common.c	/^long struct_verbosity;                   \/* verbosity level (0-4) *\/$/;"	v
structmodel	svm/svm_struct_api_types.h	/^typedef struct structmodel {$/;"	s
sub_ss	svm/svm_light/svm_common.c	/^SVECTOR* sub_ss(SVECTOR *a, SVECTOR *b) $/;"	f
sub_ss_r	svm/svm_light/svm_common.c	/^SVECTOR* sub_ss_r(SVECTOR *a, SVECTOR *b, double min_non_zero) $/;"	f
supvec	svm/svm_light/svm_common.h	/^  DOC     **supvec;$/;"	m	struct:model
sv_num	svm/svm_light/svm_common.h	/^  long    sv_num;	$/;"	m	struct:model
svector	svm/svm_light/svm_common.h	/^typedef struct svector {$/;"	s
svm_c	svm/svm_light/svm_common.h	/^  double svm_c;                \/* upper bound C on alphas *\/$/;"	m	struct:learn_parm
svm_c_factor	svm/svm_light/svm_common.h	/^  double svm_c_factor;         \/* increase C by this factor every step *\/$/;"	m	struct:learn_parm
svm_c_steps	svm/svm_light/svm_common.h	/^  long   svm_c_steps;          \/* do so many steps for finding optimal C *\/$/;"	m	struct:learn_parm
svm_cost	svm/svm_light/svm_common.h	/^  double *svm_cost;            \/* individual upper bounds for each var *\/$/;"	m	struct:learn_parm
svm_costratio	svm/svm_light/svm_common.h	/^  double svm_costratio;        \/* factor to multiply C for positive examples *\/$/;"	m	struct:learn_parm
svm_costratio_unlab	svm/svm_light/svm_common.h	/^  double svm_costratio_unlab;$/;"	m	struct:learn_parm
svm_iter_to_shrink	svm/svm_light/svm_common.h	/^  long   svm_iter_to_shrink;   \/* iterations h after which an example can$/;"	m	struct:learn_parm
svm_learn_classification	svm/svm_light/svm_learn.c	/^void svm_learn_classification(DOC **docs, double *class, long int$/;"	f
svm_learn_optimization	svm/svm_light/svm_learn.c	/^void svm_learn_optimization(DOC **docs, double *rhs, long int$/;"	f
svm_learn_ranking	svm/svm_light/svm_learn.c	/^void svm_learn_ranking(DOC **docs, double *rankvalue, long int totdoc, $/;"	f
svm_learn_regression	svm/svm_light/svm_learn.c	/^void svm_learn_regression(DOC **docs, double *value, long int totdoc, $/;"	f
svm_learn_struct	svm/svm_struct/svm_struct_learn.c	/^void svm_learn_struct(SAMPLE sample, STRUCT_LEARN_PARM *sparm,$/;"	f
svm_learn_struct_joint	svm/svm_struct/svm_struct_learn.c	/^void svm_learn_struct_joint(SAMPLE sample, STRUCT_LEARN_PARM *sparm,$/;"	f
svm_learn_struct_joint_custom	svm/svm_struct_learn_custom.c	/^void svm_learn_struct_joint_custom(SAMPLE sample, STRUCT_LEARN_PARM *sparm,$/;"	f
svm_maxqpsize	svm/svm_light/svm_common.h	/^  long   svm_maxqpsize;        \/* size q of working set *\/$/;"	m	struct:learn_parm
svm_model	svm/svm_struct_api_types.h	/^  MODEL  *svm_model;  \/* the learned SVM model *\/$/;"	m	struct:structmodel
svm_newvarsinqp	svm/svm_light/svm_common.h	/^  long   svm_newvarsinqp;      \/* new variables to enter the working set $/;"	m	struct:learn_parm
svm_struct_api	svm/svm_struct_api.h	24;"	d
svm_struct_api_types	svm/svm_struct_api_types.h	21;"	d
svm_struct_classify_api_exit	svm/svm_struct_api.c	/^void        svm_struct_classify_api_exit()$/;"	f
svm_struct_classify_api_init	svm/svm_struct_api.c	/^void        svm_struct_classify_api_init(int argc, char* argv[])$/;"	f
svm_struct_common	svm/svm_struct/svm_struct_common.h	20;"	d
svm_struct_learn_api_exit	svm/svm_struct_api.c	/^void        svm_struct_learn_api_exit()$/;"	f
svm_struct_learn_api_init	svm/svm_struct_api.c	/^void        svm_struct_learn_api_init(int argc, char* argv[])$/;"	f
svm_unlabbound	svm/svm_light/svm_common.h	/^  double svm_unlabbound;$/;"	m	struct:learn_parm
testImage	data/bin2data.py	/^	testImage = read_image('test_img')$/;"	v
testLabel	data/bin2data.py	/^	testLabel = read_label('test_lab')$/;"	v
testfile	svm/svm_struct/svm_struct_classify.c	/^char testfile[200];$/;"	v
time	svm/svm_light/svm_common.h	/^  long   time;$/;"	m	struct:kernel_cache
time_check	svm/svm_light/svm_common.h	/^  double   time_check;$/;"	m	struct:timing_profile
time_kernel	svm/svm_light/svm_common.h	/^  double   time_kernel;$/;"	m	struct:timing_profile
time_model	svm/svm_light/svm_common.h	/^  double   time_model;$/;"	m	struct:timing_profile
time_opti	svm/svm_light/svm_common.h	/^  double   time_opti;$/;"	m	struct:timing_profile
time_select	svm/svm_light/svm_common.h	/^  double   time_select;$/;"	m	struct:timing_profile
time_shrink	svm/svm_light/svm_common.h	/^  double   time_shrink;$/;"	m	struct:timing_profile
time_update	svm/svm_light/svm_common.h	/^  double   time_update;$/;"	m	struct:timing_profile
timing_profile	svm/svm_light/svm_common.h	/^typedef struct timing_profile {$/;"	s
totdoc	svm/svm_light/svm_common.h	/^  long    totdoc;       \/* number of training documents *\/$/;"	m	struct:model
totdoc2active	svm/svm_light/svm_common.h	/^  long   *totdoc2active;$/;"	m	struct:kernel_cache
totwords	svm/svm_light/svm_common.h	/^  long    totwords;     \/* number of features *\/$/;"	m	struct:model
totwords	svm/svm_light/svm_common.h	/^  long   totwords;             \/* number of features *\/$/;"	m	struct:learn_parm
trainImage	data/bin2data.py	/^	trainImage = read_image('train_img')$/;"	v
trainLabel	data/bin2data.py	/^	trainLabel = read_label('train_lab')	$/;"	v
trainfile	svm/svm_struct/svm_struct_main.c	/^char trainfile[200];           \/* file with training examples *\/$/;"	v
transduction_posratio	svm/svm_light/svm_common.h	/^  double transduction_posratio;\/* fraction of unlabeled examples to be *\/$/;"	m	struct:learn_parm
transpose_matrix	svm/svm_light/svm_common.c	/^MATRIX *transpose_matrix(MATRIX *matrix)$/;"	f
twonorm_sq	svm/svm_light/svm_common.h	/^  double  twonorm_sq;          \/* The squared euclidian length of the$/;"	m	struct:svector
type	svm/svm_light/svm_common.h	/^  long   type;                 \/* selects between regression and$/;"	m	struct:learn_parm
update_constraint_cache_for_model	svm/svm_struct/svm_struct_learn.c	/^void update_constraint_cache_for_model(CCACHE *ccache, MODEL *svmModel)$/;"	f
update_kernel_matrix	svm/svm_struct/svm_struct_learn.c	/^MATRIX *update_kernel_matrix(MATRIX *matrix, int newpos, CONSTSET *cset, $/;"	f
update_linear_component	svm/svm_light/svm_learn.c	/^void update_linear_component(DOC **docs, long int *label, $/;"	f
userdefined	svm/svm_light/svm_common.h	/^  char    *userdefined;        \/* You can put additional information$/;"	m	struct:svector
val	svm/svm_light/svm_common.h	/^  long   val,sort;$/;"	m	struct:randpair
verbosity	svm/svm_light/svm_common.c	/^long   verbosity;              \/* verbosity level (0-4) *\/$/;"	v
verbosity	svm/svm_light/svm_hideo.c	/^long verbosity;$/;"	v
verbosity	svm/svm_light/svm_loqo.c	/^long verbosity;$/;"	v
viol	svm/svm_struct/svm_struct_learn.h	/^  double  viol;     \/* violation score under current model *\/$/;"	m	struct:ccacheelem
w	svm/svm_struct_api_types.h	/^  double *w;          \/* pointer to the learned weights *\/$/;"	m	struct:structmodel
wait_any_key	svm/svm_light/svm_learn_main.c	/^void wait_any_key()$/;"	f
wait_any_key	svm/svm_struct/svm_struct_main.c	/^void wait_any_key()$/;"	f
walpha	svm/svm_struct_api_types.h	/^  double walpha;$/;"	m	struct:structmodel
weight	svm/svm_light/svm_common.h	/^  FVAL    weight;              \/* word weight *\/$/;"	m	struct:word
wnum	svm/svm_light/svm_common.h	/^  FNUM    wnum;	               \/* word number *\/$/;"	m	struct:word
word	svm/svm_light/svm_common.h	/^typedef struct word {$/;"	s
words	svm/svm_light/svm_common.h	/^  WORD    *words;              \/* The features\/values in the vector by$/;"	m	struct:svector
write_alphas	svm/svm_light/svm_learn.c	/^void write_alphas(char *alphafile, double *a, $/;"	f
write_label	svm/svm_struct_api.c	/^void        write_label(FILE *fp, LABEL y)$/;"	f
write_model	svm/svm_light/svm_common.c	/^void write_model(char *modelfile, MODEL *model)$/;"	f
write_prediction	svm/svm_light/svm_learn.c	/^void write_prediction(char *predfile, MODEL *model, double *lin, $/;"	f
write_struct_model	svm/svm_struct_api.c	/^void        write_struct_model(char *file, STRUCTMODEL *sm, $/;"	f
x	svm/svm_struct/svm_struct_common.h	/^  PATTERN x;$/;"	m	struct:example
xa_depth	svm/svm_light/svm_common.h	/^  long   xa_depth;             \/* parameter in xi\/alpha-estimates upper$/;"	m	struct:learn_parm
xa_error	svm/svm_light/svm_common.h	/^  double  xa_error,xa_recall,xa_precision;    \/* xi\/alpha estimates *\/$/;"	m	struct:model
xa_precision	svm/svm_light/svm_common.h	/^  double  xa_error,xa_recall,xa_precision;    \/* xi\/alpha estimates *\/$/;"	m	struct:model
xa_recall	svm/svm_light/svm_common.h	/^  double  xa_error,xa_recall,xa_precision;    \/* xi\/alpha estimates *\/$/;"	m	struct:model
y	svm/svm_struct/svm_struct_common.h	/^  LABEL y;$/;"	m	struct:example
